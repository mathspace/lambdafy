package main

import (
	"context"
	"fmt"
	"os"
	"sort"
	"strconv"

	"github.com/aws/aws-sdk-go-v2/aws"
	awsconfig "github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/lambda"
	"github.com/aws/aws-sdk-go-v2/service/sts"
	"github.com/mathspace/lambdafy/fnspec"
	"github.com/urfave/cli/v2"
)

var specCmd = &cli.Command{
	Name:      "spec",
	Usage:     "generate a function spec from published function",
	ArgsUsage: "function-name",
	Flags: []cli.Flag{
		versionFlag,
		&cli.StringFlag{
			Name:    "output",
			Aliases: []string{"o"},
			Usage:   "output type (yaml, json, text)",
			Value:   "yaml",
		},
	},
	Action: func(c *cli.Context) error {
		fnName := c.Args().First()
		if c.NArg() != 1 || fnName == "" {
			return fmt.Errorf("must provide a function name as the only arg")
		}
		version, err := resolveVersion(fnName, c.String("version"))
		if err != nil {
			return fmt.Errorf("failed to resolve version: %s", err)
		}

		s, err := generateSpec(fnName, version)
		if err != nil {
			return fmt.Errorf("failed to generate spec: %s", err)
		}
		fmt.Fprintf(os.Stdout, "# Generated by 'lambdafy generate-spec --version %d %s'\n\n", version, fnName)
		return s.Save(os.Stdout)
	},
}

func generateSpec(fnName string, fnVersion int) (fnspec.Spec, error) {

	spec := fnspec.Spec{}

	ctx := context.Background()
	acfg, err := awsconfig.LoadDefaultConfig(ctx)
	if err != nil {
		return spec, fmt.Errorf("failed to load aws config: %s", err)
	}
	lambdaCl := lambda.NewFromConfig(acfg)

	gfo, err := lambdaCl.GetFunction(ctx, &lambda.GetFunctionInput{
		FunctionName: &fnName,
		Qualifier:    aws.String(strconv.Itoa(fnVersion)),
	})
	if err != nil {
		return spec, err
	}

	if gfo.Code.ImageUri == nil {
		return spec, fmt.Errorf("function %s is not an docker image function", fnName)
	}

	spec.Name = fnName
	spec.Description = *gfo.Configuration.Description
	spec.Image = *gfo.Code.ImageUri
	spec.Role = *gfo.Configuration.Role
	if env := gfo.Configuration.Environment; env != nil {
		spec.Env = env.Variables
	}
	if icr := gfo.Configuration.ImageConfigResponse; icr != nil {
		if imc := icr.ImageConfig; imc != nil {
			spec.Entrypoint = imc.EntryPoint
			spec.Command = imc.Command
			spec.WorkDir = imc.WorkingDirectory
		}
	}
	spec.Memory = gfo.Configuration.MemorySize
	spec.Timeout = gfo.Configuration.Timeout
	spec.Tags = gfo.Tags
	spec.VPCSecurityGroupIds = gfo.Configuration.VpcConfig.SecurityGroupIds
	sort.StringSlice(spec.VPCSecurityGroupIds).Sort()
	spec.VPCSubnetIds = gfo.Configuration.VpcConfig.SubnetIds
	sort.StringSlice(spec.VPCSubnetIds).Sort()
	for _, fsc := range gfo.Configuration.FileSystemConfigs {
		spec.EFSMounts = append(spec.EFSMounts, fnspec.EFSMount{
			ARN:  *fsc.Arn,
			Path: *fsc.LocalMountPath,
		})
	}
	spec.TempSize = gfo.Configuration.EphemeralStorage.Size

	// Derive allowed account regions from current account and region.

	stsCl := sts.NewFromConfig(acfg)
	ident, err := stsCl.GetCallerIdentity(ctx, &sts.GetCallerIdentityInput{})
	if err != nil {
		return spec, fmt.Errorf("failed to get caller identity: %s", err)
	}
	spec.AllowedAccountRegions = []string{fmt.Sprintf("%s:%s", *ident.Account, acfg.Region)}

	return spec, nil
}
